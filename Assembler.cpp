#include "stdafx.h"
#include "Assembler.h"
#include "Errors.h"


/**/
/*
	Assembler::PassI()
  
	NAME
		PassI - first pass through the code to establish label locations.
		
	SYNOPSIS
		Assembler::PassI();

	DESCRIPTION
		Parses the assembly code and establishes the location of the labels. 
		Creates a symbol table with the symbols and their respective addresses.

	RETURNS
		Nothing

	AUTHOR
		Ashmin Bhandari

	DATE
		05/08/2018
*/
/**/

void Assembler::PassI()
{
	int loc = 0;        // Tracks the location of the instructions to be generated.

	// Successively process each line of source code.
	for (; ; ) {
		// Read the next line from the source file.
		string buff ="";
		if (!m_facc.GetNextLine(buff)) {

			// If there are no more lines, we are missing an end statement.
			// We will let this error be reported by Pass II.
			return;
		}
		// Parse the line and get the instruction type.
		Instruction::InstructionType st = m_inst.ParseInstruction(buff);

		// If this is an end statement, there is nothing left to do in pass I.
		// Pass II will determine if the end is the last statement.
		if (st == Instruction::ST_End) return;

		// Labels can only be on machine language and assembler language
		// instructions.  So, skip other instruction types.
		if (st != Instruction::ST_MachineLanguage && st != Instruction::ST_AssemblerInstr)
		{
			continue;
		}
		// If the instruction has a label, record it and its location in the
		// symbol table.
		if (m_inst.isLabel()) {

			m_symtab.AddSymbol(m_inst.GetLabel(), loc);
		}
		// Compute the location of the next instruction.
		loc = m_inst.LocationNextInstruction(loc);
	}
} 


  /**/
  /*
		Assembler::PassII()
		
		NAME
			PassII - second pass through the source code to translate the assembly code and record errors.

		SYNOPSIS
			void Assembler::PassII();

		DESCRIPTION
			Traverses the code for the second time. Uses the symbol table generated by PassI to translate the source code fed into 
			code for the VC-3600 computer. Records errors if any are encountered.

		RETURNS
			Not-a-thing. 

		AUTHOR
			Ashmin Bhandari

		DATE
			05/08/2018
  */
  /**/

void Assembler::PassII()
{
	m_facc.rewind();				// Resetting the file so that it can be read from the top again
	int loc = 0;					// Tracks the location of the instructions to be generated.
	bool is_end = false;			// Flag to indicate if the code has hit the end statement
	Errors::InitErrorReporting();	// Initializes the error reporter

	// Clear the vector containing (location, content) pair to be fed to the emulator 
	m_mcode.clear();

	// Print the top part of the translation table output . 
	cout << endl;
	cout << "Tanslation of the program:" << endl;
	cout << endl;
	cout << setw(12) << left << "Location" << setw(12) << left << "Contents" << "Original Statement" << endl;

	// Successively process each line of source code.
	for (; ; ) {
		// Read the next line from the source file.
		string buff;
		if (!m_facc.GetNextLine(buff)) {

			// Check if we returned as expected with there being no lines remaining after the code.
			if (is_end == true)
				break;

			//Report the error: If there are no more lines means end statment missing
			string error = "@location " + to_string(loc) + ": Missing end statement";
			Errors::RecordError(error);
			break;
		}

		if (is_end == true) {
			string error = "@location " + to_string(loc) + ": Lines exist after end statment";
			Errors::RecordError(error);
			break;
		}

		pair<int, string>  theTranslation = m_inst.TranslateInstruction(buff, loc);

		// Set is_end flag to true if end statement was there
		if (theTranslation == pair<int, string>(0, "end"))
			is_end = true;
		// Do not push the pair onto the vector if there is no valid machine code
		else if (theTranslation != pair<int, string>(0, "n/a"))
			m_mcode.push_back(theTranslation);

		// Compute the location of the next instruction.
		loc = m_inst.LocationNextInstruction(loc);
	}

	//Display the error messages if the record doesn't show empty
	if (!Errors::Empty()) {
		Errors::DisplayErrors();
	}
} 



